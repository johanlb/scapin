"""
Data models for CrossSourceEngine.

This module defines the core data structures used by the cross-source
search system, including results, items, and linked source definitions.
"""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any


class SourceType(str, Enum):
    """Supported data source types."""

    EMAIL = "email"
    CALENDAR = "calendar"
    TEAMS = "teams"
    WHATSAPP = "whatsapp"
    FILES = "files"
    WEB = "web"
    NOTES = "notes"


class ItemType(str, Enum):
    """Types of items returned from sources."""

    MESSAGE = "message"  # Email, Teams, WhatsApp
    EVENT = "event"  # Calendar
    FILE = "file"  # Files
    WEB_RESULT = "web_result"  # Web search
    NOTE = "note"  # Notes (Passepartout)


@dataclass
class SourceItem:
    """
    An individual result from a data source.

    Represents a single piece of information found during cross-source search,
    such as an email, calendar event, file, or web search result.
    """

    source: str  # "email", "calendar", "teams", etc.
    type: str  # "message", "event", "file", etc.
    title: str  # Subject, filename, event title, etc.
    content: str  # Content excerpt (max 500 chars)
    timestamp: datetime  # Date of the item
    relevance_score: float  # 0.0 - 1.0 (raw relevance before weighting)
    url: str | None = None  # Link to the item if applicable
    metadata: dict[str, Any] = field(default_factory=dict)
    # Computed after aggregation
    final_score: float = 0.0  # Score after source weight + freshness

    def __post_init__(self) -> None:
        """Validate and normalize fields."""
        # Truncate content to 500 chars if needed
        if len(self.content) > 500:
            self.content = self.content[:497] + "..."
        # Ensure relevance_score is in valid range
        self.relevance_score = max(0.0, min(1.0, self.relevance_score))


@dataclass
class CrossSourceResult:
    """
    Aggregated result from a cross-source search.

    Contains all items found across multiple sources, along with
    metadata about the search operation itself.
    """

    query: str
    items: list[SourceItem] = field(default_factory=list)
    sources_searched: list[str] = field(default_factory=list)
    sources_failed: list[str] = field(default_factory=list)
    total_results: int = 0
    search_duration_ms: int = 0
    from_cache: bool = False

    def __post_init__(self) -> None:
        """Compute total_results if not set."""
        if self.total_results == 0:
            self.total_results = len(self.items)


@dataclass
class LinkedSource:
    """
    A source linked to a note via frontmatter.

    Allows notes to specify which sources are most relevant for that topic,
    enabling targeted cross-source searches during note review.

    Example frontmatter:
    ```yaml
    linked_sources:
      - type: folder
        path: ~/Documents/Projets/Anahita
      - type: whatsapp
        contact: "Equipe Anahita"
    ```
    """

    type: str  # "folder", "whatsapp", "email", "teams"
    identifier: str  # Path, contact name, filter, chat name
    priority: int = 2  # 1 = high, 2 = medium, 3 = low

    @classmethod
    def from_frontmatter(cls, item: dict[str, Any]) -> "LinkedSource":
        """
        Create a LinkedSource from a frontmatter dict entry.

        Args:
            item: Dict with type and identifier fields

        Returns:
            LinkedSource instance
        """
        source_type = item.get("type", "")
        # Get identifier from various possible field names
        identifier = (
            item.get("path")
            or item.get("contact")
            or item.get("filter")
            or item.get("chat")
            or item.get("identifier")
            or ""
        )
        priority = item.get("priority", 2)

        return cls(type=source_type, identifier=identifier, priority=priority)


@dataclass
class CrossSourceRequest:
    """
    A request for cross-source search.

    Can be created manually or generated by the AI when it needs
    additional context during analysis.
    """

    query: str
    preferred_sources: list[str] | None = None  # Sources to prioritize
    exclude_sources: list[str] | None = None  # Sources to skip
    include_web: bool = False  # Explicit web search request
    max_results: int = 50
    context_note_id: str | None = None  # Note context for linked_sources

    def get_sources_to_search(self, available_sources: list[str]) -> list[str]:
        """
        Determine which sources to search based on preferences.

        Args:
            available_sources: List of all available source names

        Returns:
            List of source names to search
        """
        sources = available_sources.copy()

        # Remove web if not explicitly requested
        if not self.include_web and "web" in sources:
            sources.remove("web")

        # Remove excluded sources
        if self.exclude_sources:
            sources = [s for s in sources if s not in self.exclude_sources]

        # Reorder if preferred sources specified
        if self.preferred_sources:
            # Put preferred sources first
            preferred = [s for s in self.preferred_sources if s in sources]
            others = [s for s in sources if s not in self.preferred_sources]
            sources = preferred + others

        return sources


def parse_linked_sources(frontmatter: dict[str, Any]) -> list[LinkedSource]:
    """
    Parse linked_sources from note frontmatter.

    Args:
        frontmatter: The frontmatter dict from a note

    Returns:
        List of LinkedSource instances
    """
    sources = []
    raw_sources = frontmatter.get("linked_sources", [])

    for item in raw_sources:
        if isinstance(item, dict):
            try:
                sources.append(LinkedSource.from_frontmatter(item))
            except (KeyError, TypeError):
                # Skip invalid entries
                continue

    # Sort by priority (lower = higher priority)
    sources.sort(key=lambda s: s.priority)

    return sources
