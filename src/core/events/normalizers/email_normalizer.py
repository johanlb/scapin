"""
Email Normalizer

Converts email-specific data (EmailMetadata, EmailContent) into
universal PerceivedEvent format.

This is the bridge between existing email processing and the new
cognitive architecture.
"""

import hashlib
import re
from typing import Optional, List
from datetime import datetime

from src.core.events import (
    PerceivedEvent,
    EventSource,
    EventType,
    UrgencyLevel,
)
from src.core.schemas import EmailMetadata, EmailContent
from src.utils import now_utc


class EmailNormalizer:
    """
    Normalizes email data into universal PerceivedEvent format

    This converter preserves all important email information while
    mapping it to the source-agnostic event model.
    """

    # Keywords that suggest urgency
    URGENT_KEYWORDS = {
        "urgent", "asap", "immediately", "critical", "emergency",
        "today", "now", "quick", "time-sensitive"
    }

    # Keywords that suggest action is required
    ACTION_KEYWORDS = {
        "please", "can you", "could you", "would you", "need you to",
        "action required", "todo", "task", "required"
    }

    # Keywords that suggest it's informational
    INFO_KEYWORDS = {
        "fyi", "for your information", "heads up", "note that",
        "announcement", "update", "newsletter"
    }

    @classmethod
    def normalize(
        cls,
        metadata: EmailMetadata,
        content: EmailContent,
        perception_confidence: float = 0.7
    ) -> PerceivedEvent:
        """
        Convert email metadata and content to PerceivedEvent

        Args:
            metadata: Email metadata (subject, from, to, etc.)
            content: Email content (body text)
            perception_confidence: Initial confidence in perception (0.0-1.0)

        Returns:
            PerceivedEvent: Normalized universal event

        Raises:
            TypeError: If metadata or content are not correct types
            ValueError: If perception_confidence is out of range
        """
        # Validate input types
        if not isinstance(metadata, EmailMetadata):
            raise TypeError(
                f"metadata must be EmailMetadata, got {type(metadata).__name__}"
            )
        if not isinstance(content, EmailContent):
            raise TypeError(
                f"content must be EmailContent, got {type(content).__name__}"
            )
        if not (0.0 <= perception_confidence <= 1.0):
            raise ValueError(
                f"perception_confidence must be 0.0-1.0, got {perception_confidence}"
            )

        # Generate unique event ID from email metadata
        event_id = cls._generate_event_id(metadata)

        # Extract entities (people, dates, topics)
        entities = cls._extract_entities(metadata, content)

        # Classify event type
        event_type = cls._classify_event_type(metadata, content)

        # Determine urgency
        urgency = cls._determine_urgency(metadata, content)

        # Extract topics and keywords
        topics = cls._extract_topics(metadata, content)
        keywords = cls._extract_keywords(content)

        # Extract URLs
        urls = cls._extract_urls(content)

        # Determine thread information
        thread_id = cls._extract_thread_id(metadata)
        in_reply_to = cls._extract_in_reply_to(metadata)

        # Create perceived event
        event = PerceivedEvent(
            # Identity
            event_id=event_id,
            source=EventSource.EMAIL,
            source_id=str(metadata.id),

            # Timing
            occurred_at=metadata.date,
            received_at=metadata.date,  # For emails, these are the same
            perceived_at=now_utc(),

            # Core Content
            title=metadata.subject,
            content=content.plain_text or content.html or "",
            summary=None,  # Will be generated by AI if needed

            # Classification
            event_type=event_type,
            urgency=urgency,

            # Extracted Information
            entities=entities,
            topics=topics,
            keywords=keywords,

            # Participants
            from_person=metadata.from_address,
            to_people=metadata.to_addresses,
            cc_people=metadata.cc_addresses or [],

            # Context Links
            thread_id=thread_id,
            references=metadata.references or [],
            in_reply_to=in_reply_to,

            # Attachments
            has_attachments=metadata.has_attachments,
            attachment_count=len(metadata.attachments) if metadata.attachments else 0,
            attachment_types=cls._extract_attachment_types(metadata),
            urls=urls,

            # Source-Specific Data
            metadata={
                "email_flags": metadata.flags,
                "email_folder": metadata.folder,
                "email_size_bytes": metadata.size_bytes,
                "email_message_id": metadata.message_id,
                "email_from_name": metadata.from_name,
                "attachments": [
                    {
                        "filename": att.filename,
                        "size_bytes": att.size_bytes,
                        "content_type": att.content_type,
                    }
                    for att in (metadata.attachments or [])
                ],
            },

            # Quality Metrics
            perception_confidence=perception_confidence,
            needs_clarification=False,  # Will be determined by reasoning engine
            clarification_questions=[],
        )

        return event

    @classmethod
    def _generate_event_id(cls, metadata: EmailMetadata) -> str:
        """
        Generate unique event ID from email metadata

        Uses message_id if available, otherwise generates from UID and folder.
        """
        if metadata.message_id:
            # Use email message ID as base
            base = f"email:{metadata.message_id}"
        else:
            # Fallback: Use UID and folder
            base = f"email:{metadata.folder}:{metadata.id}"

        # Generate hash for consistent ID
        hash_obj = hashlib.sha256(base.encode())
        return hash_obj.hexdigest()[:16]  # 16 character hex

    @classmethod
    def _extract_entities(
        cls,
        metadata: EmailMetadata,
        content: EmailContent
    ) -> List:
        """
        Extract entities from email

        For now, extracts basic entities. Will be enhanced with NER in future.
        """
        from src.core.events import Entity

        entities = []

        # Add sender as person entity
        # Confidence 0.95: Email parsing is reliable but not perfect (spoofing possible)
        if metadata.from_address:
            entities.append(Entity(
                type="person",
                value=metadata.from_address,
                confidence=0.95,
                metadata={"name": metadata.from_name, "role": "sender"}
            ))

        # Add recipients as person entities
        # Confidence 0.95: Recipients from email headers are very reliable
        for recipient in metadata.to_addresses:
            entities.append(Entity(
                type="person",
                value=recipient,
                confidence=0.95,
                metadata={"role": "recipient"}
            ))

        # Future: Add NER for organizations, locations, dates, etc.

        return entities

    @classmethod
    def _classify_event_type(
        cls,
        metadata: EmailMetadata,
        content: EmailContent
    ) -> EventType:
        """
        Classify email into event type

        This is initial rough classification. Reasoning engine will refine.
        """
        text = (metadata.subject + " " + (content.plain_text or "")).lower()

        # Check for reply first (explicit signal)
        if metadata.subject.startswith("Re:") or metadata.in_reply_to:
            return EventType.REPLY

        # Check for action required
        if any(keyword in text for keyword in cls.ACTION_KEYWORDS):
            return EventType.ACTION_REQUIRED

        # Check for FYI/informational
        if any(keyword in text for keyword in cls.INFO_KEYWORDS):
            return EventType.INFORMATION

        # Check for invitation (simple heuristic)
        if "invite" in text or "meeting" in text or "calendar" in text:
            return EventType.INVITATION

        # Default to information
        return EventType.INFORMATION

    @classmethod
    def _determine_urgency(
        cls,
        metadata: EmailMetadata,
        content: EmailContent
    ) -> UrgencyLevel:
        """
        Determine urgency level from email content

        This is initial heuristic. Reasoning engine will refine.
        """
        text = (metadata.subject + " " + (content.plain_text or "")).lower()

        # Check for urgent keywords
        if any(keyword in text for keyword in cls.URGENT_KEYWORDS):
            return UrgencyLevel.HIGH

        # Check email flags
        if metadata.flags and "\\Flagged" in metadata.flags:
            return UrgencyLevel.HIGH

        # Check for deadlines (simple heuristic)
        if "deadline" in text or "due" in text:
            return UrgencyLevel.MEDIUM

        # Default to low
        return UrgencyLevel.LOW

    @classmethod
    def _extract_topics(
        cls,
        metadata: EmailMetadata,
        content: EmailContent
    ) -> List[str]:
        """
        Extract main topics from email

        Uses subject as primary topic. For emails without subjects,
        extracts from first line of content. Will be enhanced with topic modeling.
        """
        topics = []

        # Use subject as primary topic
        if metadata.subject and metadata.subject.strip():
            # Clean subject (remove Re:, Fwd:, etc.)
            clean_subject = re.sub(r'^(Re:|Fwd:|Fw:)\s*', '', metadata.subject, flags=re.IGNORECASE)
            clean_subject = clean_subject.strip()
            if clean_subject:  # Only add if not empty after cleaning
                topics.append(clean_subject)

        # Fallback: Extract from first line of content if no subject
        if not topics and content.plain_text:
            first_line = content.plain_text.split('\n')[0].strip()
            if first_line and len(first_line) <= 100:  # Reasonable topic length
                topics.append(first_line)

        return topics

    @classmethod
    def _extract_keywords(cls, content: EmailContent) -> List[str]:
        """
        Extract important keywords from content

        Simple implementation for now. Will be enhanced with TF-IDF or similar.
        """
        # For now, return empty list
        # Future: Implement keyword extraction
        return []

    @classmethod
    def _extract_urls(cls, content: EmailContent) -> List[str]:
        """
        Extract URLs from email content

        Deduplicates while preserving order of first occurrence.
        """
        text = content.plain_text or content.html or ""

        # Simple URL regex
        url_pattern = r'https?://[^\s<>"{}|\\^`\[\]]+'
        urls = re.findall(url_pattern, text)

        # Deduplicate while preserving order
        return list(dict.fromkeys(urls))

    @classmethod
    def _extract_thread_id(cls, metadata: EmailMetadata) -> Optional[str]:
        """
        Extract thread ID from email metadata

        Thread ID represents the root of the conversation thread.

        Strategy:
        1. If References header exists, use references[0] (conversation root)
           - References should contain full thread chain: [root, parent1, parent2, ...]
           - First element is always the original message that started the thread
        2. Else if In-Reply-To exists, use it as thread identifier
           - Not guaranteed to be root, but indicates thread membership
        3. Else use message_id (this email starts a new thread)

        Note: This is "best effort" thread identification based on a single email's
        headers. Some email clients don't properly maintain References headers,
        which can cause thread fragmentation. For robust thread detection, use
        ContinuityDetector with multiple events.

        Known limitation: If references[0] is not the true root (malformed headers),
        thread detection may fail. See archived bug report:
        /archive/phase_reports/BUG_CONVERSATION_DETECTION.md
        """
        # Priority 1: References header (most reliable for threading)
        if metadata.references and len(metadata.references) > 0:
            # Validation: If in_reply_to exists, it should be in references
            if metadata.in_reply_to and metadata.in_reply_to not in metadata.references:
                # Malformed headers - references should contain in_reply_to
                # Fall back to in_reply_to as it's more likely to be correct
                return metadata.in_reply_to

            # Return first reference (thread root)
            return metadata.references[0]

        # Priority 2: In-Reply-To (direct parent reference)
        if metadata.in_reply_to:
            return metadata.in_reply_to

        # Priority 3: Message-ID (new thread root)
        # This email starts a new conversation thread
        return metadata.message_id

    @classmethod
    def _extract_in_reply_to(cls, metadata: EmailMetadata) -> Optional[str]:
        """Extract in-reply-to reference"""
        return metadata.in_reply_to

    @classmethod
    def _extract_attachment_types(cls, metadata: EmailMetadata) -> List[str]:
        """Extract attachment file types"""
        if not metadata.attachments:
            return []

        types = set()
        for attachment in metadata.attachments:
            # Get file extension
            if "." in attachment.filename:
                ext = attachment.filename.rsplit(".", 1)[-1].lower()
                types.add(ext)

        return list(types)
