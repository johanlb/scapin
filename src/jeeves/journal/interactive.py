"""
Journal Interactive Mode

Interactive session for completing daily journal using questionary.
Collects user answers to questions and corrections for feedback.
"""

import time
import uuid
from typing import Optional

import questionary
from rich.console import Console
from rich.panel import Panel
from rich.table import Table

from src.core.events.universal_event import now_utc
from src.jeeves.journal.models import (
    Correction,
    EmailSummary,
    JournalEntry,
    JournalQuestion,
    JournalStatus,
    QuestionCategory,
)
from src.monitoring.logger import get_logger

logger = get_logger("jeeves.journal.interactive")

# Rich console for output
console = Console()


class JournalInteractive:
    """
    Interactive journal session

    Guides the user through questions generated by JournalGenerator,
    collects answers and corrections, and returns a completed journal.

    Example:
        >>> entry = generator.generate(date.today())
        >>> interactive = JournalInteractive(entry)
        >>> completed = interactive.run()
        >>> print(f"Completed in {completed.duration_minutes} minutes")
    """

    def __init__(self, entry: JournalEntry):
        """
        Initialize interactive session

        Args:
            entry: Draft journal entry from generator
        """
        self.entry = entry
        self.start_time: Optional[float] = None

    def run(self) -> JournalEntry:
        """
        Run the interactive session

        Returns:
            Completed journal entry with answers and corrections
        """
        self.start_time = time.time()
        self.entry.status = JournalStatus.IN_PROGRESS

        try:
            # Show summary
            self._show_summary()

            # Process questions
            if self.entry.questions:
                self._process_questions()

            # Ask about corrections
            self._collect_corrections()

            # Ask for notes
            self._collect_notes()

            # Complete
            duration = int((time.time() - self.start_time) / 60)
            self.entry.complete(duration)

            console.print()
            console.print(Panel.fit(
                f"[bold green]Journal complete en {duration} minutes[/bold green]",
                border_style="green"
            ))

            return self.entry

        except KeyboardInterrupt:
            console.print("\n[yellow]Session interrompue[/yellow]")
            # Keep what we have
            duration = int((time.time() - self.start_time) / 60)
            self.entry.duration_minutes = duration
            return self.entry

    def _show_summary(self) -> None:
        """Show summary of the day's processing"""
        console.print()
        console.print(Panel.fit(
            f"[bold blue]Journal du {self.entry.journal_date}[/bold blue]",
            border_style="blue"
        ))
        console.print()

        # Stats table
        table = Table(show_header=False, box=None)
        table.add_column("Label", style="dim")
        table.add_column("Value", style="bold")

        table.add_row("Emails traites", str(len(self.entry.emails_processed)))
        table.add_row("  Haute confiance (>=85%)", str(len(self.entry.high_confidence_emails)))
        table.add_row("  Basse confiance (<85%)", str(len(self.entry.low_confidence_emails)))
        table.add_row("Taches creees", str(len(self.entry.tasks_created)))
        table.add_row("Confiance moyenne", f"{self.entry.average_confidence:.1f}%")
        table.add_row("Questions", str(len(self.entry.questions)))

        console.print(table)
        console.print()

    def _process_questions(self) -> None:
        """Process all questions interactively"""
        questions = sorted(self.entry.questions, key=lambda q: q.priority)

        console.print(f"[bold]Repondez aux {len(questions)} questions suivantes :[/bold]")
        console.print("[dim]Appuyez sur Ctrl+C pour passer les questions restantes[/dim]")
        console.print()

        for i, question in enumerate(questions, 1):
            console.print(f"[bold cyan]Question {i}/{len(questions)}[/bold cyan]")
            self._show_question_context(question)

            try:
                answer = self._ask_question(question)

                if answer == "Passer":
                    console.print("[dim]Question passee[/dim]")
                    continue

                # Record answer
                self.entry.answer_question(question.question_id, answer)
                console.print("[green]Reponse enregistree[/green]")

            except KeyboardInterrupt:
                console.print("\n[yellow]Questions restantes passees[/yellow]")
                break

            console.print()

    def _show_question_context(self, question: JournalQuestion) -> None:
        """Show context for a question"""
        category_icons = {
            QuestionCategory.NEW_PERSON: "New contact",
            QuestionCategory.LOW_CONFIDENCE: "Verification",
            QuestionCategory.CLARIFICATION: "Clarification",
            QuestionCategory.ACTION_VERIFY: "Action check",
        }

        category_label = category_icons.get(question.category, question.category.value)
        console.print(f"[dim]{category_label}[/dim]")
        console.print(f"[dim italic]{question.context}[/dim italic]")

    def _ask_question(self, question: JournalQuestion) -> str:
        """Ask a single question and get answer"""
        choices = list(question.options) + ["Passer"]

        # For simple yes/no, use confirm
        if question.options == ("Oui, correct", "Non, incorrect"):
            result = questionary.confirm(
                question.question_text,
                default=True,
            ).ask()

            if result is None:  # Ctrl+C
                return "Passer"
            return "Oui, correct" if result else "Non, incorrect"

        # For multiple choice
        answer = questionary.select(
            question.question_text,
            choices=choices,
        ).ask()

        if answer is None:  # Ctrl+C
            return "Passer"

        # If "Autre" selected, ask for custom input
        if answer == "Autre":
            custom = questionary.text("Votre reponse :").ask()
            return custom if custom else "Autre (non specifie)"

        return answer

    def _collect_corrections(self) -> None:
        """Collect corrections from user"""
        if not self.entry.emails_processed:
            return

        console.print()
        want_corrections = questionary.confirm(
            "Voulez-vous signaler des corrections sur les decisions prises ?",
            default=False,
        ).ask()

        if not want_corrections:
            return

        console.print()
        console.print("[bold]Selection des emails a corriger :[/bold]")

        # Show emails with confidence
        email_choices = []
        for email in self.entry.emails_processed:
            label = f"{email.subject[:40]} ({email.action}, {email.confidence}%)"
            email_choices.append(questionary.Choice(label, value=email))

        email_choices.append(questionary.Choice("Terminer les corrections", value=None))

        while True:
            selected = questionary.select(
                "Selectionnez un email a corriger :",
                choices=email_choices,
            ).ask()

            if selected is None:
                break

            correction = self._create_correction(selected)
            if correction:
                self.entry.add_correction(correction)
                console.print("[green]Correction enregistree[/green]")

            console.print()

    def _create_correction(self, email: EmailSummary) -> Optional[Correction]:
        """Create a correction for an email"""
        console.print()
        console.print(f"[bold]Correction pour :[/bold] {email.subject}")
        console.print(f"[dim]Action actuelle : {email.action} | Categorie : {email.category}[/dim]")
        console.print()

        # Ask what to correct
        correction_type = questionary.select(
            "Que voulez-vous corriger ?",
            choices=[
                "L'action (archive, delete, task, etc.)",
                "La categorie",
                "Les deux",
                "Annuler",
            ],
        ).ask()

        if correction_type == "Annuler":
            return None

        corrected_action = None
        corrected_category = None

        # Correct action
        if correction_type in ("L'action (archive, delete, task, etc.)", "Les deux"):
            corrected_action = questionary.select(
                "Quelle aurait du etre l'action ?",
                choices=["archive", "delete", "create_task", "reply_needed", "forward", "review_later"],
            ).ask()

        # Correct category
        if correction_type in ("La categorie", "Les deux"):
            corrected_category = questionary.select(
                "Quelle aurait du etre la categorie ?",
                choices=["work", "personal", "newsletter", "notification", "spam", "important", "other"],
            ).ask()

        # Ask for reason
        reason = questionary.text(
            "Pourquoi cette correction ? (optionnel)",
        ).ask()

        return Correction(
            correction_id=str(uuid.uuid4()),
            email_id=email.email_id,
            original_action=email.action,
            original_category=email.category,
            original_confidence=email.confidence,
            corrected_action=corrected_action,
            corrected_category=corrected_category,
            reason=reason if reason else None,
            timestamp=now_utc(),
        )

    def _collect_notes(self) -> None:
        """Collect free-form notes from user"""
        console.print()
        want_notes = questionary.confirm(
            "Voulez-vous ajouter des notes libres ?",
            default=False,
        ).ask()

        if not want_notes:
            return

        console.print("[dim]Entrez vos notes (Entree vide pour terminer) :[/dim]")
        notes = questionary.text(
            "Notes :",
            multiline=True,
        ).ask()

        if notes:
            self.entry.notes = notes
            console.print("[green]Notes enregistrees[/green]")
