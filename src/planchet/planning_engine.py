"""
Planning Engine - Convert Understanding to Action Plan

Takes WorkingMemory from Sancho reasoning and generates an executable action plan.
"""

import time
from collections import deque
from dataclasses import dataclass, field
from enum import Enum
from typing import TYPE_CHECKING, Any, Optional

from src.core.memory.working_memory import Hypothesis, WorkingMemory
from src.monitoring.logger import get_logger

# Avoid circular import
if TYPE_CHECKING:
    from src.figaro.actions.base import Action

# Import ExecutionMode and ActionResult at runtime
from src.figaro.actions.base import ExecutionMode

logger = get_logger("planchet.planning_engine")

# Risk assessment constants
RISK_SCORE_REVERSIBLE = 0.3  # Impact score for reversible actions
RISK_SCORE_IRREVERSIBLE = 0.6  # Impact score for irreversible actions


# Custom exceptions for dependency issues
class DependencyCycleError(Exception):
    """Raised when action dependencies form a cycle"""
    pass


class MissingDependencyError(Exception):
    """Raised when an action has dependencies not in the action list"""
    pass


class RiskLevel(str, Enum):
    """Risk level for actions"""
    LOW = "low"          # Safe, reversible, low impact
    MEDIUM = "medium"    # Some risk, partially reversible
    HIGH = "high"        # Significant risk, hard to reverse
    CRITICAL = "critical"  # Major impact, irreversible


@dataclass
class RiskAssessment:
    """Risk assessment for an action"""
    action_id: str
    risk_level: RiskLevel
    reversible: bool
    impact_score: float  # 0-1, higher = bigger impact
    concerns: list[str] = field(default_factory=list)
    mitigations: list[str] = field(default_factory=list)

    def requires_approval(self) -> bool:
        """Check if this risk level requires user approval"""
        return self.risk_level in [RiskLevel.HIGH, RiskLevel.CRITICAL]


@dataclass
class ActionPlan:
    """
    Executable action plan

    Generated by PlanningEngine from WorkingMemory.
    Contains ordered list of actions with dependency resolution.
    """
    actions: list["Action"]  # Topologically sorted by dependencies
    execution_mode: ExecutionMode
    risks: list[RiskAssessment]
    rationale: str  # Why these actions were chosen
    estimated_duration: float  # Total estimated time in seconds
    confidence: float  # Planning confidence (0-1)
    metadata: dict[str, Any] = field(default_factory=dict)

    def requires_approval(self) -> bool:
        """Check if plan requires user approval"""
        # Review mode always requires approval
        if self.execution_mode == ExecutionMode.REVIEW:
            return True

        # Check if any action has high risk
        return any(risk.requires_approval() for risk in self.risks)

    def get_action_by_id(self, action_id: str) -> Optional["Action"]:
        """Find action by ID"""
        for action in self.actions:
            if action.action_id == action_id:
                return action
        return None

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for serialization"""
        return {
            "actions": [
                {
                    "id": action.action_id,
                    "type": action.action_type,
                    "dependencies": action.dependencies()
                }
                for action in self.actions
            ],
            "execution_mode": self.execution_mode,
            "risks": [
                {
                    "action_id": risk.action_id,
                    "risk_level": risk.risk_level,
                    "reversible": risk.reversible,
                    "impact_score": risk.impact_score
                }
                for risk in self.risks
            ],
            "rationale": self.rationale,
            "estimated_duration": self.estimated_duration,
            "confidence": self.confidence,
            "metadata": self.metadata
        }


class PlanningEngine:
    """
    Planning Engine - WorkingMemory → ActionPlan

    Responsibilities:
    1. Analyze WorkingMemory (understanding from Sancho)
    2. Generate candidate actions
    3. Assess risks for each action
    4. Resolve dependencies
    5. Determine execution mode
    6. Create ordered ActionPlan

    Usage:
        engine = PlanningEngine()
        plan = engine.plan(working_memory, user_preferences)
    """

    def __init__(
        self,
        auto_approve_threshold: float = 0.95,
        risk_tolerance: RiskLevel = RiskLevel.MEDIUM
    ):
        """
        Initialize planning engine

        Args:
            auto_approve_threshold: Confidence threshold for auto execution (0-1)
            risk_tolerance: Maximum acceptable risk level for auto execution
        """
        self.auto_approve_threshold = auto_approve_threshold
        self.risk_tolerance = risk_tolerance

        logger.info(
            "Initialized PlanningEngine",
            extra={
                "auto_approve_threshold": auto_approve_threshold,
                "risk_tolerance": risk_tolerance
            }
        )

    def plan(
        self,
        working_memory: WorkingMemory,
        available_actions: Optional[list["Action"]] = None
    ) -> ActionPlan:
        """
        Generate action plan from working memory

        Args:
            working_memory: WorkingMemory from Sancho reasoning
            available_actions: Optional list of actions to choose from
                             If None, generates default actions from hypothesis

        Returns:
            ActionPlan with ordered actions and execution mode
        """
        start_time = time.time()

        # Get best hypothesis from working memory
        if not working_memory.current_best_hypothesis:
            logger.warning("No hypothesis in working memory, creating empty plan")
            return self._create_empty_plan("No hypothesis available")

        # current_best_hypothesis is already a Hypothesis object
        best_hypothesis = working_memory.current_best_hypothesis

        # Generate or use provided actions
        if available_actions is None:
            actions = self._generate_actions_from_hypothesis(best_hypothesis)
        else:
            actions = available_actions

        # Assess risks
        risks = self._assess_risks(actions)

        # Resolve dependencies and order actions
        ordered_actions = self._resolve_dependencies(actions)

        # Determine execution mode
        execution_mode = self._determine_execution_mode(
            ordered_actions,
            risks,
            working_memory.overall_confidence
        )

        # Generate rationale
        rationale = self._generate_rationale(best_hypothesis, ordered_actions)

        # Calculate total duration
        total_duration = sum(action.estimated_duration() for action in ordered_actions)

        duration = time.time() - start_time

        plan = ActionPlan(
            actions=ordered_actions,
            execution_mode=execution_mode,
            risks=risks,
            rationale=rationale,
            estimated_duration=total_duration,
            confidence=working_memory.overall_confidence,
            metadata={
                "hypothesis_id": best_hypothesis.id,
                "planning_duration": duration,
                "action_count": len(ordered_actions)
            }
        )

        logger.info(
            "Generated action plan",
            extra={
                "action_count": len(ordered_actions),
                "execution_mode": execution_mode,
                "confidence": working_memory.overall_confidence,
                "duration": duration
            }
        )

        return plan

    def _generate_actions_from_hypothesis(self, hypothesis: Hypothesis) -> list["Action"]:
        """
        Generate actions from hypothesis

        For now, returns empty list. Concrete actions should be provided
        by the caller based on the hypothesis.

        Args:
            hypothesis: Best hypothesis from reasoning

        Returns:
            List of Action objects
        """
        # In production, this would analyze hypothesis and generate appropriate actions
        # For now, return empty list - actions should be provided by caller
        logger.debug(
            f"Generating actions for hypothesis: {hypothesis.description}"
        )
        return []

    def _assess_risks(self, actions: list["Action"]) -> list[RiskAssessment]:
        """
        Assess risk for each action

        Args:
            actions: List of actions to assess

        Returns:
            List of RiskAssessment objects
        """
        risks = []

        for action in actions:
            # Simple risk assessment based on action properties
            # Check if action type supports undo
            can_undo = action.supports_undo()
            risk_level = RiskLevel.LOW if can_undo else RiskLevel.MEDIUM

            risk = RiskAssessment(
                action_id=action.action_id,
                risk_level=risk_level,
                reversible=can_undo,
                impact_score=RISK_SCORE_REVERSIBLE if can_undo else RISK_SCORE_IRREVERSIBLE,
                concerns=[] if can_undo else ["Action cannot be undone"],
                mitigations=["Can rollback" if can_undo else "Review before execution"]
            )
            risks.append(risk)

        return risks

    def _resolve_dependencies(self, actions: list["Action"]) -> list["Action"]:
        """
        Resolve action dependencies and return topologically sorted list

        Args:
            actions: List of actions (possibly unordered)

        Returns:
            List of actions in dependency order

        Raises:
            MissingDependencyError: If an action depends on a non-existent action
            DependencyCycleError: If dependencies form a cycle
            ValueError: If actions list is empty
        """
        if not actions:
            logger.warning("Empty actions list provided to dependency resolution")
            return []

        # Build dependency graph
        action_map = {action.action_id: action for action in actions}
        in_degree = {action.action_id: 0 for action in actions}
        adj_list = {action.action_id: [] for action in actions}

        # Validate all dependencies exist
        missing_deps = []
        for action in actions:
            for dep_id in action.dependencies():
                if dep_id not in action_map:
                    missing_deps.append({
                        "action_id": action.action_id,
                        "action_type": action.action_type,
                        "missing_dependency": dep_id
                    })
                else:
                    # Dependency exists, add to graph
                    adj_list[dep_id].append(action.action_id)
                    in_degree[action.action_id] += 1

        if missing_deps:
            logger.error(
                "Missing dependencies detected",
                extra={"missing": missing_deps}
            )
            raise MissingDependencyError(
                f"Actions have missing dependencies: {missing_deps}"
            )

        # Kahn's algorithm for topological sort
        # Use deque for O(1) popleft instead of O(n) pop(0)
        queue = deque([aid for aid in in_degree if in_degree[aid] == 0])
        result = []

        while queue:
            current_id = queue.popleft()  # O(1) instead of pop(0) which is O(n)
            result.append(action_map[current_id])

            for neighbor_id in adj_list[current_id]:
                in_degree[neighbor_id] -= 1
                if in_degree[neighbor_id] == 0:
                    queue.append(neighbor_id)

        # Check for cycles
        if len(result) != len(actions):
            # Find which actions are in the cycle
            unprocessed = set(action_map.keys()) - {a.action_id for a in result}
            logger.error(
                "Dependency cycle detected",
                extra={"cycle_actions": list(unprocessed)}
            )
            raise DependencyCycleError(
                f"Circular dependencies detected in actions: {list(unprocessed)}"
            )

        return result

    def _determine_execution_mode(
        self,
        actions: list["Action"],
        risks: list[RiskAssessment],
        confidence: float
    ) -> ExecutionMode:
        """
        Determine execution mode based on risks and confidence

        Args:
            actions: List of actions
            risks: Risk assessments
            confidence: Overall confidence (0-1)

        Returns:
            ExecutionMode (AUTO, REVIEW, or MANUAL)
        """
        # No actions → manual
        if not actions:
            return ExecutionMode.MANUAL

        # Low confidence → review
        if confidence < self.auto_approve_threshold:
            return ExecutionMode.REVIEW

        # High risk → review
        max_risk = max((risk.risk_level for risk in risks), default=RiskLevel.LOW)
        if max_risk.value > self.risk_tolerance.value:
            return ExecutionMode.REVIEW

        # High confidence + acceptable risk → auto
        return ExecutionMode.AUTO

    def _generate_rationale(
        self,
        hypothesis: Hypothesis,
        actions: list["Action"]
    ) -> str:
        """Generate human-readable rationale for the plan"""
        if not actions:
            return f"No actions needed for: {hypothesis.description}"

        action_summary = ", ".join(action.action_type for action in actions)
        return f"Based on '{hypothesis.description}', planning to: {action_summary}"

    def _create_empty_plan(self, reason: str) -> ActionPlan:
        """Create empty plan with reason"""
        return ActionPlan(
            actions=[],
            execution_mode=ExecutionMode.MANUAL,
            risks=[],
            rationale=reason,
            estimated_duration=0.0,
            confidence=0.0
        )
